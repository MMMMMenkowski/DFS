# ---------------------------------------------------------------
# Copyright (c) 2021, NVIDIA Corporation. All rights reserved.
#
# This work is licensed under the NVIDIA Source Code License
# ---------------------------------------------------------------
import math
from termios import B1000000
from tkinter import YES
from turtle import forward
import warnings
import numpy as np
from functools import partial

import torch
import torch.nn as nn
import torch.nn.functional as F

from torch import einsum
from torch.nn import Softmax
from einops import rearrange, repeat
#from inplace_abn import InPlaceABN, 


def _no_grad_trunc_normal_(tensor, mean, std, a, b):
    # Cut & paste from PyTorch official master until it's in a few official releases - RW
    # Method based on https://people.sc.fsu.edu/~jburkardt/presentations/truncated_normal.pdf
    def norm_cdf(x):
        # Computes standard normal cumulative distribution function
        return (1. + math.erf(x / math.sqrt(2.))) / 2.

    if (mean < a - 2 * std) or (mean > b + 2 * std):
        warnings.warn("mean is more than 2 std from [a, b] in nn.init.trunc_normal_. "
                      "The distribution of values may be incorrect.",
                      stacklevel=2)

    with torch.no_grad():
        # Values are generated by using a truncated uniform distribution and
        # then using the inverse CDF for the normal distribution.
        # Get upper and lower cdf values
        l = norm_cdf((a - mean) / std)
        u = norm_cdf((b - mean) / std)

        # Uniformly fill tensor with values from [l, u], then translate to
        # [2l-1, 2u-1].
        tensor.uniform_(2 * l - 1, 2 * u - 1)

        # Use inverse cdf transform for normal distribution to get truncated
        # standard normal
        tensor.erfinv_()

        # Transform to proper mean, std
        tensor.mul_(std * math.sqrt(2.))
        tensor.add_(mean)

        # Clamp to ensure it's in the proper range
        tensor.clamp_(min=a, max=b)
        return tensor


def trunc_normal_(tensor, mean=0., std=1., a=-2., b=2.):
    r"""
    Fills the input Tensor with values drawn from a truncated
    normal distribution. The values are effectively drawn from the
    normal distribution :math:`\mathcal{N}(\text{mean}, \text{std}^2)`
    with values outside :math:`[a, b]` redrawn until they are within
    the bounds. The method used for generating the random values works
    best when :math:`a \leq \text{mean} \leq b`.
    Args:
        tensor: an n-dimensional `torch.Tensor`
        mean: the mean of the normal distribution
        std: the standard deviation of the normal distribution
        a: the minimum cutoff value
        b: the maximum cutoff value
    Examples:
        >>> w = torch.empty(3, 5)
        >>> nn.init.trunc_normal_(w)
    """
    return _no_grad_trunc_normal_(tensor, mean, std, a, b)

#--------------------------------------#
#   Gelu激活函数的实现
#   利用近似的数学公式
#--------------------------------------#
class GELU(nn.Module):
    def __init__(self):
        super(GELU, self).__init__()

    def forward(self, x):
        return 0.5 * x * (1 + torch.tanh(np.sqrt(2 / np.pi) * (x + 0.044715 * torch.pow(x,3))))


def drop_path(x, drop_prob: float = 0., training: bool = False, scale_by_keep: bool = True):
    """
    Drop paths (Stochastic Depth) per sample (when applied in main path of residual blocks).
    This is the same as the DropConnect impl I created for EfficientNet, etc networks, however,
    the original name is misleading as 'Drop Connect' is a different form of dropout in a separate paper...
    See discussion: https://github.com/tensorflow/tpu/issues/494#issuecomment-532968956 ... I've opted for
    changing the layer and argument names to 'drop path' rather than mix DropConnect as a layer name and use
    'survival rate' as the argument.
    """
    if drop_prob == 0. or not training:
        return x
    keep_prob       = 1 - drop_prob
    shape           = (x.shape[0],) + (1,) * (x.ndim - 1)  # work with diff dim tensors, not just 2D ConvNets
    random_tensor   = x.new_empty(shape).bernoulli_(keep_prob)
    if keep_prob > 0.0 and scale_by_keep:
        random_tensor.div_(keep_prob)
    return x * random_tensor

class DropPath(nn.Module):
    def __init__(self, drop_prob=None, scale_by_keep=True):
        super(DropPath, self).__init__()
        self.drop_prob = drop_prob
        self.scale_by_keep = scale_by_keep

    def forward(self, x):
        return drop_path(x, self.drop_prob, self.training, self.scale_by_keep)


#========================================================================
#                           mynet                                      
#========================================================================

class Compensation_Module(nn.Module):
    def __init__(self, in_channels, drop_path, reduction=4, lambda_c=0.5, lambda_s=0.5, act_layer=GELU) -> None:
        super().__init__()
        # input: B, C, H, W
        self.dim = in_channels
        self.lambda_c = lambda_c
        self.lambda_s = lambda_s
        self.softmax = Softmax(dim=-1)
        self.drop_path = DropPath(drop_path)
        self.spatial_weight = nn.Sequential(nn.Conv2d(in_channels*2, in_channels*2//reduction, kernel_size=1, stride=1, padding=0), 
                                      nn.BatchNorm2d(in_channels*2//reduction, eps=0.001, momentum=0.03),
                                      nn.ReLU(inplace=True),
                                      nn.Conv2d(in_channels*2//reduction, 2, kernel_size=1, stride=1, padding=0), 
                                      #nn.BatchNorm2d(2, eps=0.001, momentum=0.03),
                                      nn.Sigmoid())
        self.max_pool = nn.AdaptiveMaxPool2d(1)
        self.avg_pool = nn.AdaptiveAvgPool2d(1)
        self.channel_weight = nn.Sequential(nn.Linear(4*in_channels, 4*in_channels//reduction), 
                                 nn.ReLU(inplace=True),
                                 nn.Linear(4*in_channels//reduction, 2*in_channels),
                                 nn.Sigmoid()) #既可以学习通道重要性，也在学习max和avg的权重
        
        self.act = act_layer()
        self.apply(self._init_weights)

    def _init_weights(self, m):
        if isinstance(m, nn.Linear):
            trunc_normal_(m.weight, std=.02)
            if isinstance(m, nn.Linear) and m.bias is not None:
                nn.init.constant_(m.bias, 0)
        elif isinstance(m, nn.LayerNorm):
            nn.init.constant_(m.bias, 0)
            nn.init.constant_(m.weight, 1.0)
        elif isinstance(m, nn.Conv2d):
            fan_out = m.kernel_size[0] * m.kernel_size[1] * m.out_channels
            fan_out //= m.groups
            m.weight.data.normal_(0, math.sqrt(2.0 / fan_out))
            if m.bias is not None:
                m.bias.data.zero_()
                
    def forward(self, x, y):
        b, c, h, w = x.shape # x和y形状应该相同
        #x = x.flatten(2).permute(0,2,1) # B, N, C
        #y = y.flatten(2).permute(0,2,1)
        spatial_weights = self.spatial_weight(torch.cat([x,y],dim=1))
        spatial_weight_x = self.softmax(spatial_weights[:, 0, :, :].reshape(b, -1)).reshape(b, 1, h, w)
        spatial_weight_y = self.softmax(spatial_weights[:, 1, :, :].reshape(b, -1)).reshape(b, 1, h, w)
        
        channel_weights = self.channel_weight(torch.cat([self.max_pool(x).reshape(b, c),
                                                         self.avg_pool(x).reshape(b, c), 
                                                         self.max_pool(y).reshape(b, c), 
                                                         self.avg_pool(y).reshape(b, c)], dim=-1)).reshape(b, -1, c)
        channel_weight_x = self.softmax(channel_weights[:, 0, :].reshape(b ,-1)).reshape(b, c, 1, 1)
        channel_weight_y = self.softmax(channel_weights[:, 1, :].reshape(b ,-1)).reshape(b, c, 1, 1)
        
        return x + self.drop_path(self.lambda_c * channel_weight_y * y + self.lambda_s * spatial_weight_y * y),\
                y + self.drop_path(self.lambda_c * channel_weight_x * x + self.lambda_s * spatial_weight_x * x)


def INF(B,H,W):
     return -torch.diag(torch.tensor(float("inf")).repeat(H),0).unsqueeze(0).repeat(B*W,1,1)

class CrissAttention(nn.Module):
    """ Criss-Cross Attention Module"""
    def __init__(self, in_dim):
        super(CrissAttention,self).__init__()
        self.query_conv = nn.Conv2d(in_channels=in_dim, out_channels=in_dim//8, kernel_size=1)
        self.key_conv = nn.Conv2d(in_channels=in_dim, out_channels=in_dim//8, kernel_size=1)
        self.value_conv = nn.Conv2d(in_channels=in_dim, out_channels=in_dim, kernel_size=1)
        self.softmax = Softmax(dim=3)
        #self.drop_path = DropPath(drop_path)
        self.INF = INF
        self.gamma = nn.Parameter(torch.zeros(1))
        self.apply(self._init_weights)

    def _init_weights(self, m):
        if isinstance(m, nn.Linear):
            trunc_normal_(m.weight, std=.02)
            if isinstance(m, nn.Linear) and m.bias is not None:
                nn.init.constant_(m.bias, 0)
        elif isinstance(m, nn.LayerNorm):
            nn.init.constant_(m.bias, 0)
            nn.init.constant_(m.weight, 1.0)
        elif isinstance(m, nn.Conv2d):
            fan_out = m.kernel_size[0] * m.kernel_size[1] * m.out_channels
            fan_out //= m.groups
            m.weight.data.normal_(0, math.sqrt(2.0 / fan_out))
            if m.bias is not None:
                m.bias.data.zero_()

    def forward(self, x):
        m_batchsize, _, height, width = x.size()
        proj_query = self.query_conv(x)
        proj_query_H = proj_query.permute(0,3,1,2).contiguous().view(m_batchsize*width,-1,height).permute(0, 2, 1)
        proj_query_W = proj_query.permute(0,2,1,3).contiguous().view(m_batchsize*height,-1,width).permute(0, 2, 1)
        proj_key = self.key_conv(x)
        proj_key_H = proj_key.permute(0,3,1,2).contiguous().view(m_batchsize*width,-1,height)
        proj_key_W = proj_key.permute(0,2,1,3).contiguous().view(m_batchsize*height,-1,width)
        proj_value = self.value_conv(x)
        proj_value_H = proj_value.permute(0,3,1,2).contiguous().view(m_batchsize*width,-1,height)
        proj_value_W = proj_value.permute(0,2,1,3).contiguous().view(m_batchsize*height,-1,width)
        energy_H = (torch.bmm(proj_query_H, proj_key_H)+self.INF(m_batchsize, height, width).to(x.device)).view(m_batchsize,width,height,height).permute(0,2,1,3)
        energy_W = torch.bmm(proj_query_W, proj_key_W).view(m_batchsize,height,width,width)
        # b, h, w, w+h
        concate = self.softmax(torch.cat([energy_H, energy_W], 3))

        att_H = concate[:,:,:,0:height].permute(0,2,1,3).contiguous().view(m_batchsize*width,height,height)
        #print(concate)
        #print(att_H) 
        att_W = concate[:,:,:,height:height+width].contiguous().view(m_batchsize*height,width,width)
        out_H = torch.bmm(proj_value_H, att_H.permute(0, 2, 1)).view(m_batchsize,width,-1,height).permute(0,2,3,1)
        out_W = torch.bmm(proj_value_W, att_W.permute(0, 2, 1)).view(m_batchsize,height,-1,width).permute(0,2,1,3)
        #print(out_H.size(),out_W.size())
        return self.gamma*(out_H + out_W) + x
    
    
class Recurrent_Criss_Atten_Encoder(nn.Module):
    def __init__(self, in_channels, out_channels):
        super(Recurrent_Criss_Atten_Encoder, self).__init__()
        inter_channels = in_channels // 4
        self.conva = nn.Sequential(nn.Conv2d(in_channels, inter_channels, 3, padding=1, bias=False),
                                   nn.BatchNorm2d(inter_channels))
        self.cca = CrissAttention(inter_channels)
        self.convb = nn.Sequential(nn.Conv2d(inter_channels, inter_channels, 3, padding=1, bias=False),
                                   nn.BatchNorm2d(inter_channels))

        self.bottleneck = nn.Sequential(
            nn.Conv2d(in_channels+inter_channels, out_channels, kernel_size=3, padding=1, dilation=1, bias=False),
            nn.BatchNorm2d(out_channels),
            nn.Dropout2d(0.1),
            nn.Conv2d(out_channels, out_channels, kernel_size=1, stride=1, padding=0, bias=True)
            )
        self.apply(self._init_weights)

    def _init_weights(self, m):
        if isinstance(m, nn.Linear):
            trunc_normal_(m.weight, std=.02)
            if isinstance(m, nn.Linear) and m.bias is not None:
                nn.init.constant_(m.bias, 0)
        elif isinstance(m, nn.LayerNorm):
            nn.init.constant_(m.bias, 0)
            nn.init.constant_(m.weight, 1.0)
        elif isinstance(m, nn.Conv2d):
            fan_out = m.kernel_size[0] * m.kernel_size[1] * m.out_channels
            fan_out //= m.groups
            m.weight.data.normal_(0, math.sqrt(2.0 / fan_out))
            if m.bias is not None:
                m.bias.data.zero_()

    def forward(self, x, recurrence=3):
        #x = x['out']
        output = self.conva(x)
        for i in range(recurrence):
            output = self.cca(output)
        output = self.convb(output)

        output = self.bottleneck(torch.cat([x, output], 1))
        #print('RCCA',output.shape)
        return output
    
    
class Cross_CrissAttention(nn.Module): #从上面改下
    def __init__(self, in_dim) -> None:
        super().__init__()
        self.query_conv_x = nn.Conv2d(in_channels=in_dim, out_channels=in_dim//8, kernel_size=1)
        self.key_conv_x = nn.Conv2d(in_channels=in_dim, out_channels=in_dim//8, kernel_size=1)
        self.value_conv_x = nn.Conv2d(in_channels=in_dim, out_channels=in_dim, kernel_size=1)
        
        self.query_conv_y = nn.Conv2d(in_channels=in_dim, out_channels=in_dim//8, kernel_size=1)
        self.key_conv_y = nn.Conv2d(in_channels=in_dim, out_channels=in_dim//8, kernel_size=1)
        self.value_conv_y = nn.Conv2d(in_channels=in_dim, out_channels=in_dim, kernel_size=1)
        
        self.softmax = Softmax(dim=3)
        self.INF = INF
        self.gamma_x, self.gamma_y = nn.Parameter(torch.zeros(1)), nn.Parameter(torch.zeros(1))
        self.apply(self._init_weights)

    def _init_weights(self, m):
        if isinstance(m, nn.Linear):
            trunc_normal_(m.weight, std=.02)
            if isinstance(m, nn.Linear) and m.bias is not None:
                nn.init.constant_(m.bias, 0)
        elif isinstance(m, nn.LayerNorm):
            nn.init.constant_(m.bias, 0)
            nn.init.constant_(m.weight, 1.0)
        elif isinstance(m, nn.Conv2d):
            fan_out = m.kernel_size[0] * m.kernel_size[1] * m.out_channels
            fan_out //= m.groups
            m.weight.data.normal_(0, math.sqrt(2.0 / fan_out))
            if m.bias is not None:
                m.bias.data.zero_()
        
    def forward(self, x, y):
        m_batchsize, _, height, width = x.size()
        proj_query_x = self.query_conv_x(x)
        proj_query_y = self.query_conv_y(y)
        proj_query_H_x = proj_query_x.permute(0,3,1,2).contiguous().view(m_batchsize*width,-1,height).permute(0, 2, 1)
        proj_query_W_x = proj_query_x.permute(0,2,1,3).contiguous().view(m_batchsize*height,-1,width).permute(0, 2, 1)
        proj_query_H_y = proj_query_y.permute(0,3,1,2).contiguous().view(m_batchsize*width,-1,height).permute(0, 2, 1)
        proj_query_W_y = proj_query_y.permute(0,2,1,3).contiguous().view(m_batchsize*height,-1,width).permute(0, 2, 1)
        
        proj_key_x = self.key_conv_x(x)
        proj_key_y = self.key_conv_y(y)
        proj_key_H_x = proj_key_x.permute(0,3,1,2).contiguous().view(m_batchsize*width,-1,height)
        proj_key_W_x = proj_key_x.permute(0,2,1,3).contiguous().view(m_batchsize*height,-1,width)
        proj_key_H_y = proj_key_y.permute(0,3,1,2).contiguous().view(m_batchsize*width,-1,height)
        proj_key_W_y = proj_key_y.permute(0,2,1,3).contiguous().view(m_batchsize*height,-1,width)
        
        proj_value_x = self.value_conv_x(x)
        proj_value_y = self.value_conv_y(y)
        proj_value_H_x = proj_value_x.permute(0,3,1,2).contiguous().view(m_batchsize*width,-1,height)
        proj_value_W_x = proj_value_x.permute(0,2,1,3).contiguous().view(m_batchsize*height,-1,width)
        proj_value_H_y = proj_value_y.permute(0,3,1,2).contiguous().view(m_batchsize*width,-1,height)
        proj_value_W_y = proj_value_y.permute(0,2,1,3).contiguous().view(m_batchsize*height,-1,width)
        
        energy_H_x = (torch.bmm(proj_query_H_x, proj_key_H_y)+self.INF(m_batchsize, height, width).to(x.device)).view(m_batchsize,width,height,height).permute(0,2,1,3)
        energy_W_x = torch.bmm(proj_query_W_x, proj_key_W_y).view(m_batchsize,height,width,width)
        energy_H_y = (torch.bmm(proj_query_H_y, proj_key_H_x)+self.INF(m_batchsize, height, width).to(y.device)).view(m_batchsize,width,height,height).permute(0,2,1,3)
        energy_W_y = torch.bmm(proj_query_W_y, proj_key_W_x).view(m_batchsize,height,width,width)
        concate_x = self.softmax(torch.cat([energy_H_x, energy_W_x], 3))
        concate_y = self.softmax(torch.cat([energy_H_y, energy_W_y], 3))

        att_H_x = concate_x[:,:,:,0:height].permute(0,2,1,3).contiguous().view(m_batchsize*width,height,height)
        att_W_x = concate_x[:,:,:,height:height+width].contiguous().view(m_batchsize*height,width,width)
        out_H_x = torch.bmm(proj_value_H_x, att_H_x.permute(0, 2, 1)).view(m_batchsize,width,-1,height).permute(0,2,3,1)
        out_W_x = torch.bmm(proj_value_W_x, att_W_x.permute(0, 2, 1)).view(m_batchsize,height,-1,width).permute(0,2,1,3)
        att_H_y = concate_y[:,:,:,0:height].permute(0,2,1,3).contiguous().view(m_batchsize*width,height,height)
        att_W_y = concate_y[:,:,:,height:height+width].contiguous().view(m_batchsize*height,width,width)
        
        out_H_y = torch.bmm(proj_value_H_y, att_H_y.permute(0, 2, 1)).view(m_batchsize,width,-1,height).permute(0,2,3,1)
        out_W_y = torch.bmm(proj_value_W_y, att_W_y.permute(0, 2, 1)).view(m_batchsize,height,-1,width).permute(0,2,1,3)
        #print(out_H.size(),out_W.size())
        return self.gamma_x*(out_H_x + out_W_x) + x, self.gamma_y*(out_H_y + out_W_y) + y


class Recurrent_Cross_Criss_Fusion_Module(nn.Module):
    def __init__(self, in_channels, drop_path) -> None:
        super().__init__()
        inter_channels = in_channels // 4
        self.ccca = Cross_CrissAttention(inter_channels)
        self.drop_path = DropPath(drop_path)
        
        self.conva_x = nn.Sequential(nn.Conv2d(in_channels, inter_channels, 3, padding=1, bias=False),
                                   nn.BatchNorm2d(inter_channels))
        self.convb_x = nn.Sequential(nn.Conv2d(inter_channels, inter_channels, 3, padding=1, bias=False),
                                   nn.BatchNorm2d(inter_channels))
        self.bottleneck_x = nn.Sequential(
            nn.Conv2d(in_channels+inter_channels, in_channels, kernel_size=3, padding=1, dilation=1, bias=False),
            nn.BatchNorm2d(in_channels),
            nn.Dropout2d(0.1),
            nn.Conv2d(in_channels, in_channels, kernel_size=1, stride=1, padding=0, bias=True)
            )
        
        self.conva_y = nn.Sequential(nn.Conv2d(in_channels, inter_channels, 3, padding=1, bias=False),
                                   nn.BatchNorm2d(inter_channels))
        self.convb_y = nn.Sequential(nn.Conv2d(inter_channels, inter_channels, 3, padding=1, bias=False),
                                   nn.BatchNorm2d(inter_channels))
        self.bottleneck_y = nn.Sequential(
            nn.Conv2d(in_channels+inter_channels, in_channels, kernel_size=3, padding=1, dilation=1, bias=False),
            nn.BatchNorm2d(in_channels),
            nn.Dropout2d(0.1),
            nn.Conv2d(in_channels, in_channels, kernel_size=1, stride=1, padding=0, bias=True)
            )
        self.apply(self._init_weights)

    def _init_weights(self, m):
        if isinstance(m, nn.Linear):
            trunc_normal_(m.weight, std=.02)
            if isinstance(m, nn.Linear) and m.bias is not None:
                nn.init.constant_(m.bias, 0)
        elif isinstance(m, nn.LayerNorm):
            nn.init.constant_(m.bias, 0)
            nn.init.constant_(m.weight, 1.0)
        elif isinstance(m, nn.Conv2d):
            fan_out = m.kernel_size[0] * m.kernel_size[1] * m.out_channels
            fan_out //= m.groups
            m.weight.data.normal_(0, math.sqrt(2.0 / fan_out))
            if m.bias is not None:
                m.bias.data.zero_()
        
    def forward(self, x, y, recurrence=2):
        output_x, output_y = self.conva_x(x), self.conva_y(y)
        for i in range(recurrence):
            output_x, output_y = self.ccca(output_x, output_y)
        output_x, output_y = self.convb_x(output_x), self.convb_y(output_y)
        return self.drop_path(self.bottleneck_x(torch.cat([output_x, x], dim=1)))+x, \
                self.drop_path(self.bottleneck_y(torch.cat([output_y, y],dim=1)))+y
    

class Patch_Merging(nn.Module):
    def __init__(self, in_channels, downscale=2) -> None:
        super().__init__()
        self.pm = nn.Sequential(nn.Conv2d(in_channels, in_channels, kernel_size=1),
                                nn.BatchNorm2d(in_channels),
                                nn.Dropout2d(0.1),
                                nn.Conv2d(in_channels, in_channels*2, kernel_size=downscale, stride=downscale, padding=0))
        self.apply(self._init_weights)

    def _init_weights(self, m):
        if isinstance(m, nn.Linear):
            trunc_normal_(m.weight, std=.02)
            if isinstance(m, nn.Linear) and m.bias is not None:
                nn.init.constant_(m.bias, 0)
        elif isinstance(m, nn.LayerNorm):
            nn.init.constant_(m.bias, 0)
            nn.init.constant_(m.weight, 1.0)
        elif isinstance(m, nn.Conv2d):
            fan_out = m.kernel_size[0] * m.kernel_size[1] * m.out_channels
            fan_out //= m.groups
            m.weight.data.normal_(0, math.sqrt(2.0 / fan_out))
            if m.bias is not None:
                m.bias.data.zero_()
                
    def forward(self, x):
        return self.pm(x)
    

class Patch_Embedding(nn.Module):
    def __init__(self, inchan=3, patch_size=4, dim=48) -> None:
        super().__init__()
        # b, 3, h, w => b, dim, h//4, w//4
        self.dim = dim
        self.sz = patch_size
        self.emb = nn.Conv2d(inchan, dim, kernel_size=patch_size, stride=patch_size, padding=0)
        self.apply(self._init_weights)

    def _init_weights(self, m):
        if isinstance(m, nn.Linear):
            trunc_normal_(m.weight, std=.02)
            if isinstance(m, nn.Linear) and m.bias is not None:
                nn.init.constant_(m.bias, 0)
        elif isinstance(m, nn.LayerNorm):
            nn.init.constant_(m.bias, 0)
            nn.init.constant_(m.weight, 1.0)
        elif isinstance(m, nn.Conv2d):
            fan_out = m.kernel_size[0] * m.kernel_size[1] * m.out_channels
            fan_out //= m.groups
            m.weight.data.normal_(0, math.sqrt(2.0 / fan_out))
            if m.bias is not None:
                m.bias.data.zero_()
                
    def forward(self, x):
        
        return self.emb(x)# + position_emb
        

class Criss_Block(nn.Module):
    def __init__(self, dim, drop_path, reduction=4, lambda_c=0.5, lambda_s=0.5, recurrence=2, **kwargs) -> None:
        super().__init__()
        self.recurrence = recurrence
        self.RCAE_x = Recurrent_Criss_Atten_Encoder(dim, dim)
        self.RCAE_y = Recurrent_Criss_Atten_Encoder(dim, dim)
        self.CM = Compensation_Module(dim, drop_path, reduction=reduction, lambda_c=lambda_c, lambda_s=lambda_s)
        self.RCCFM = Recurrent_Cross_Criss_Fusion_Module(dim, drop_path)
        self.drop_path = DropPath(drop_path)
        #self.PM_x = Patch_Merging(dim)
        #self.PM_y = Patch_Merging(dim)
        self.apply(self._init_weights)

    def _init_weights(self, m):
        if isinstance(m, nn.Linear):
            trunc_normal_(m.weight, std=.02)
            if isinstance(m, nn.Linear) and m.bias is not None:
                nn.init.constant_(m.bias, 0)
        elif isinstance(m, nn.LayerNorm):
            nn.init.constant_(m.bias, 0)
            nn.init.constant_(m.weight, 1.0)
        elif isinstance(m, nn.Conv2d):
            fan_out = m.kernel_size[0] * m.kernel_size[1] * m.out_channels
            fan_out //= m.groups
            m.weight.data.normal_(0, math.sqrt(2.0 / fan_out))
            if m.bias is not None:
                m.bias.data.zero_()
                
    def forward(self, x, y):
        output_x, output_y = self.RCAE_x(x, self.recurrence), self.RCAE_y(y, self.recurrence)
        output_x, output_y = self.CM(output_x, output_y)
        output_x, output_y = self.RCCFM(output_x, output_y, self.recurrence)
        return x+self.drop_path(output_x), y+self.drop_path(output_y)


#========================================================================
#                           Swin Widgets                                      
#========================================================================


class CyclicShift(nn.Module):
    def __init__(self, displacement):
        super().__init__()
        self.displacement = displacement

    def forward(self, x):
        return torch.roll(x, shifts=(self.displacement, self.displacement), dims=(1, 2))


class Residual(nn.Module):
    def __init__(self, fn):
        super().__init__()
        self.fn = fn

    def forward(self, x, **kwargs):
        return self.fn(x, **kwargs) + x


class PreNorm(nn.Module):
    def __init__(self, dim, fn):
        super().__init__()
        self.norm = nn.LayerNorm(dim)
        self.fn = fn

    def forward(self, x, **kwargs):
        return self.fn(self.norm(x), **kwargs)


class FeedForward(nn.Module):
    def __init__(self, dim, hidden_dim):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(dim, hidden_dim),
            nn.GELU(),
            nn.Linear(hidden_dim, dim),
        )
        
    def forward(self, x):
        return self.net(x)


def create_mask(window_size, displacement, upper_lower, left_right):
    mask = torch.zeros(window_size ** 2, window_size ** 2) # 局部计算自注意力的窗口内的mask
    if upper_lower:
        mask[-displacement * window_size:, :-displacement * window_size] = float('-inf')
        mask[:-displacement * window_size, -displacement * window_size:] = float('-inf')
    if left_right:
        mask = rearrange(mask, '(h1 w1) (h2 w2) -> h1 w1 h2 w2', h1=window_size, h2=window_size)
        mask[:, -displacement:, :, :-displacement] = float('-inf')
        mask[:, :-displacement, :, -displacement:] = float('-inf')
        mask = rearrange(mask, 'h1 w1 h2 w2 -> (h1 w1) (h2 w2)')
    return mask


def get_relative_distances(window_size):
    indices = torch.tensor(np.array([[x, y] for x in range(window_size) for y in range(window_size)]))
    distances = indices[None, :, :] - indices[:, None, :]
    return distances

    
class WindowAttention(nn.Module):
    def __init__(self, dim, heads, head_dim, shifted, window_size, relative_pos_embedding):
        super().__init__()
        inner_dim = head_dim * heads
        self.heads = heads
        self.scale = head_dim ** -0.5
        self.window_size = window_size
        self.relative_pos_embedding = relative_pos_embedding
        self.shifted = shifted
        if self.shifted:
            displacement = window_size // 2
            self.cyclic_shift = CyclicShift(-displacement)
            self.cyclic_back_shift = CyclicShift(displacement)
            self.upper_lower_mask = nn.Parameter(create_mask(window_size=window_size, displacement=displacement,
                                                             upper_lower=True, left_right=False), requires_grad=False)
            self.left_right_mask = nn.Parameter(create_mask(window_size=window_size, displacement=displacement,
                                                            upper_lower=False, left_right=True), requires_grad=False)
        self.to_qkv = nn.Linear(dim, inner_dim * 3, bias=False)
        if self.relative_pos_embedding:
            self.relative_indices = get_relative_distances(window_size) + window_size - 1
            self.pos_embedding = nn.Parameter(torch.randn(2 * window_size - 1, 2 * window_size - 1))
        else:
            self.pos_embedding = nn.Parameter(torch.randn(window_size ** 2, window_size ** 2))
        self.to_out = nn.Linear(inner_dim, dim)

    def forward(self, x):
        if self.shifted:
            x = self.cyclic_shift(x)
        b, n_h, n_w, _, h = *x.shape, self.heads
        
        #print(x.permute(0,2,3,1).shape)
        qkv = self.to_qkv(x).chunk(3, dim=-1)
        #print(qkv[0].shape, qkv[1].shape, qkv[2].shape)
        #raise
        nw_h = n_h // self.window_size
        nw_w = n_w // self.window_size
        '''
        if n_h % self.window_size != 0:
            nw_h += 1
            nw_w += 1
            paddings = (self.window_size-n_h%self.window_size, self.window_size-n_w%self.window_size)
            qkv = map(lambda t: F.pad(t, pad=(0, 0, 0, paddings[1], 0, paddings[0])), qkv)
        ''' 
        q, k, v = map(lambda t: rearrange(t, 'b (nw_h w_h) (nw_w w_w) (h d) -> b h (nw_h nw_w) (w_h w_w) d',
                                h=h, w_h=self.window_size, w_w=self.window_size), qkv)
        dots = einsum('b h w i d, b h w j d -> b h w i j', q, k) * self.scale
        if self.relative_pos_embedding:
            dots += self.pos_embedding[self.relative_indices[:, :, 0], self.relative_indices[:, :, 1]]
        else:
            dots += self.pos_embedding
        if self.shifted:
            dots[:, :, -nw_w:] += self.upper_lower_mask
            dots[:, :, nw_w - 1::nw_w] += self.left_right_mask
        attn = dots.softmax(dim=-1)
        out = einsum('b h w i j, b h w j d -> b h w i d', attn, v)
        #print(out.shape)
        #print(nw_w)
        out = rearrange(out, 'b h (nw_h nw_w) (w_h w_w) d -> b (nw_h w_h) (nw_w w_w) (h d)',
                        h=h, w_h=self.window_size, w_w=self.window_size, nw_h=nw_h, nw_w=nw_w)
        out = self.to_out(out)
        if self.shifted:
            out = self.cyclic_back_shift(out)
        return out


class CrossWindowAttention(nn.Module):
    def __init__(self, dim, heads, head_dim, shifted, window_size, relative_pos_embedding):
        super().__init__()
        inner_dim = head_dim * heads
        self.heads = heads
        self.scale = head_dim ** -0.5
        self.window_size = window_size
        self.relative_pos_embedding = relative_pos_embedding
        self.shifted = shifted
        if self.shifted:
            displacement = window_size // 2
            self.cyclic_shift = CyclicShift(-displacement)
            self.cyclic_back_shift = CyclicShift(displacement)
            self.upper_lower_mask = nn.Parameter(create_mask(window_size=window_size, displacement=displacement,
                                                             upper_lower=True, left_right=False), requires_grad=False)
            self.left_right_mask = nn.Parameter(create_mask(window_size=window_size, displacement=displacement,
                                                            upper_lower=False, left_right=True), requires_grad=False)
        self.to_qkv_x = nn.Linear(dim, inner_dim * 3, bias=False)
        self.to_qkv_y = nn.Linear(dim, inner_dim * 3, bias=False)
        if self.relative_pos_embedding:
            self.relative_indices = get_relative_distances(window_size) + window_size - 1
            self.pos_embedding = nn.Parameter(torch.randn(2 * window_size - 1, 2 * window_size - 1))
        else:
            self.pos_embedding = nn.Parameter(torch.randn(window_size ** 2, window_size ** 2))
        self.to_out_x = nn.Linear(inner_dim, dim)
        self.to_out_y = nn.Linear(inner_dim, dim)

    def forward(self, x, y):
        if self.shifted:
            x = self.cyclic_shift(x)
            y = self.cyclic_shift(y)
        b, n_h, n_w, _, h = *x.shape, self.heads
        
        qkv_x = self.to_qkv_x(x).chunk(3, dim=-1)
        qkv_y = self.to_qkv_y(y).chunk(3, dim=-1)
        
        nw_h = n_h // self.window_size
        nw_w = n_w // self.window_size
        '''
        if n_h % self.window_size != 0:
            nw_h += 1
            nw_w += 1
            paddings = (self.window_size-n_h%self.window_size, self.window_size-n_w%self.window_size)
            qkv_x = map(lambda t: F.pad(t, pad=(0, 0, 0, paddings[1], 0, paddings[0])), qkv_x)
            qkv_y = map(lambda t: F.pad(t, pad=(0, 0, 0, paddings[1], 0, paddings[0])), qkv_y)
        '''
        q_x, k_x, v_x = map(lambda t: rearrange(t, 'b (nw_h w_h) (nw_w w_w) (h d) -> b h (nw_h nw_w) (w_h w_w) d',
                                h=h, w_h=self.window_size, w_w=self.window_size), qkv_x)
        q_y, k_y, v_y = map(lambda t: rearrange(t, 'b (nw_h w_h) (nw_w w_w) (h d) -> b h (nw_h nw_w) (w_h w_w) d',
                                h=h, w_h=self.window_size, w_w=self.window_size), qkv_y)
        
        dots_x = einsum('b h w i d, b h w j d -> b h w i j', q_x, k_y) * self.scale
        dots_y = einsum('b h w i d, b h w j d -> b h w i j', q_y, k_x) * self.scale
        
        if self.relative_pos_embedding:
            dots_x += self.pos_embedding[self.relative_indices[:, :, 0], self.relative_indices[:, :, 1]]
            dots_y += self.pos_embedding[self.relative_indices[:, :, 0], self.relative_indices[:, :, 1]]
        else:
            dots_x += self.pos_embedding
            dots_y += self.pos_embedding
            
        if self.shifted:
            dots_x[:, :, -nw_w:] += self.upper_lower_mask
            dots_y[:, :, -nw_w:] += self.upper_lower_mask
            dots_x[:, :, nw_w - 1::nw_w] += self.left_right_mask
            dots_y[:, :, nw_w - 1::nw_w] += self.left_right_mask
            
        attn_x = dots_x.softmax(dim=-1)
        attn_y = dots_y.softmax(dim=-1)
        
        out_x = einsum('b h w i j, b h w j d -> b h w i d', attn_x, v_y)
        out_y = einsum('b h w i j, b h w j d -> b h w i d', attn_y, v_x)
        out_x = rearrange(out_x, 'b h (nw_h nw_w) (w_h w_w) d -> b (nw_h w_h) (nw_w w_w) (h d)',
                        h=h, w_h=self.window_size, w_w=self.window_size, nw_h=nw_h, nw_w=nw_w)
        out_y = rearrange(out_y, 'b h (nw_h nw_w) (w_h w_w) d -> b (nw_h w_h) (nw_w w_w) (h d)',
                        h=h, w_h=self.window_size, w_w=self.window_size, nw_h=nw_h, nw_w=nw_w)
        
        out_x = self.to_out_x(out_x)
        out_y = self.to_out_y(out_y)
        
        if self.shifted:
            out_x, out_y = self.cyclic_back_shift(out_x), self.cyclic_back_shift(out_y)
        return out_x, out_y


class Recurrent_Swin_Atten_Encoder(nn.Module):
    def __init__(self, dim, heads, head_dim, mlp_dim, window_size, relative_pos_embedding=True) -> None:
        super().__init__()
        self.attention_block = nn.ModuleList([WindowAttention(dim=dim,heads=heads,head_dim=head_dim,shifted=False,
                                                            window_size=window_size,relative_pos_embedding=relative_pos_embedding),
                                                WindowAttention(dim=dim,heads=heads,head_dim=head_dim,shifted=True,
                                                            window_size=window_size,relative_pos_embedding=relative_pos_embedding)])
        self.mlp_block = Residual(PreNorm(dim, FeedForward(dim=dim, hidden_dim=mlp_dim)))
        
        
    def forward(self, x, recurence=2):
        x = x.permute(0,2,3,1)
        for i in range(recurence):
            for att in self.attention_block:
                x = att(x)
            x = self.mlp_block(x)
        return x.permute(0,3,1,2)
    
class Recurrent_Cross_Swin_Fusion_Module(nn.Module):
    def __init__(self, dim, heads, head_dim, mlp_dim, window_size, relative_pos_embedding=True):
        super().__init__()
        self.attention_block = nn.ModuleList([CrossWindowAttention(dim=dim,heads=heads,head_dim=head_dim,shifted=False,
                                                                   window_size=window_size,relative_pos_embedding=relative_pos_embedding),
                                              CrossWindowAttention(dim=dim,heads=heads,head_dim=head_dim,shifted=True,
                                                                   window_size=window_size,relative_pos_embedding=relative_pos_embedding)]) 
        self.norm = nn.LayerNorm(dim)
        self.mlp_x = Residual(PreNorm(dim, FeedForward(dim=dim, hidden_dim=mlp_dim)))
        self.mlp_y = Residual(PreNorm(dim, FeedForward(dim=dim, hidden_dim=mlp_dim)))
        
    def forward(self, x, y, recurrence=2):
        x, y = x.permute(0,2,3,1), y.permute(0,2,3,1)
        for i in range(recurrence):
            for catt in self.attention_block:
                x_, y_ = catt(x, y)
                x, y = self.norm(x_)+x, self.norm(y_)+y
            x, y = self.mlp_x(x), self.mlp_y(y)
        return x.permute(0,3,1,2), y.permute(0,3,1,2)

        
class Swin_Block(nn.Module):
    def __init__(self, dim, drop_path, **kwargs) -> None:
        super().__init__()
        if 'lambda_c' not in kwargs:
            kwargs['lambda_c'] = 0.5
        if 'lambda_s' not in kwargs:
            kwargs['lambda_s'] = 0.5
        if 'reduction' not in kwargs:
            kwargs['reduction'] = 4
        
        if 'abl' in kwargs and kwargs['abl'] is not None and kwargs['abl'].split('_')[0]=='ablation':
            self.abl = kwargs['abl'].split('_')
        else:
            self.abl = None
        
        self.recurrence = kwargs['recurrence']
        if 'heads' in kwargs:
            heads = kwargs['heads']
        else:
            heads = 8
        if 'head_dim' in kwargs:
            head_dim = kwargs['head_dim']
        else:
            head_dim = dim // heads
        self.RSAE_x = Recurrent_Swin_Atten_Encoder(dim, heads=heads, head_dim=head_dim, mlp_dim=dim*4, window_size=kwargs['window_size'])
        self.RSAE_y = Recurrent_Swin_Atten_Encoder(dim, heads=heads, head_dim=head_dim, mlp_dim=dim*4, window_size=kwargs['window_size'])
        self.CM = Compensation_Module(dim, drop_path, reduction=kwargs['reduction'], lambda_c=kwargs['lambda_c'], lambda_s=kwargs['lambda_s'])
        self.RCSFM = Recurrent_Cross_Swin_Fusion_Module(dim, heads=heads, head_dim=head_dim, mlp_dim=dim*4, window_size=kwargs['window_size'])
        self.drop_path = DropPath(drop_path)
        #self.PM_x = Patch_Merging(dim)
        #self.PM_y = Patch_Merging(dim)
        self.apply(self._init_weights)

    def _init_weights(self, m):
        if isinstance(m, nn.Linear):
            trunc_normal_(m.weight, std=.02)
            if isinstance(m, nn.Linear) and m.bias is not None:
                nn.init.constant_(m.bias, 0)
        elif isinstance(m, nn.LayerNorm):
            nn.init.constant_(m.bias, 0)
            nn.init.constant_(m.weight, 1.0)
        elif isinstance(m, nn.Conv2d):
            fan_out = m.kernel_size[0] * m.kernel_size[1] * m.out_channels
            fan_out //= m.groups
            m.weight.data.normal_(0, math.sqrt(2.0 / fan_out))
            if m.bias is not None:
                m.bias.data.zero_()
                
    def forward(self, x, y):
        output_x, output_y = x, y
        if self.abl is None or 'SwinEncoder' in self.abl:
            output_x, output_y = self.RSAE_x(x, self.recurrence), self.RSAE_y(y, self.recurrence)
        if self.abl is None or 'Compensate' in self.abl:
            output_x, output_y = self.CM(output_x, output_y)
        if self.abl is None or 'CrossSwin' in self.abl:
            output_x, output_y = self.RCSFM(output_x, output_y, self.recurrence)
        return x+self.drop_path(output_x), y+self.drop_path(output_y)


class Encoder(nn.Module):
    def __init__(self, num_classes=5, attention='criss', **kwargs) -> None:
        super().__init__()
        #self.dims = dims
        #self.num_classes = num_classes
        #self.layers = layers
        self.mode = attention
        self.kwargs = kwargs
        if attention=='criss':
            _Block = Criss_Block
        elif attention=='swin':
            _Block = Swin_Block
        else:
            raise NotImplementedError
        #print(kwargs)
        #inchans = kwargs['inchans']
        #drop_path_rate = kwargs['drop_rate']
        #layers = kwargs['layers']
        #recurrence = kwargs['recurrence']
        #window_size = kwargs['window_size']
        dim = kwargs['dims']
        dims = []
        for i in range(4):
            dims.append(dim)
            dim *= 2
        self.PE_x = Patch_Embedding(inchan=kwargs['inchans'][0], dim=dims[0])
        self.PE_y = Patch_Embedding(inchan=kwargs['inchans'][1], dim=dims[0])
        self.norms = nn.ModuleList([nn.BatchNorm2d(dim) for dim in dims]) 
        dpr = [x.item() for x in torch.linspace(0, kwargs['drop_rate'], sum(kwargs['layers']))]
        cur = 0
        self.blocks = nn.ModuleList([])
        
        for i in range(len(kwargs['layers'])):
            #print(i)
            self.blocks.add_module('block'+str(i+1), nn.ModuleList([_Block(dims[i], dpr[cur+j], **kwargs) for j in range(kwargs['layers'][i])]))
            cur += kwargs['layers'][i]
        self.pm_xs = nn.ModuleList([Patch_Merging(dims[i], 2) for i in range(len(dims)-1)])
        self.pm_ys = nn.ModuleList([Patch_Merging(dims[i], 2) for i in range(len(dims)-1)])
        
        self.apply(self._init_weights)

    def _init_weights(self, m):
        if isinstance(m, nn.Linear):
            trunc_normal_(m.weight, std=.02)
            if isinstance(m, nn.Linear) and m.bias is not None:
                nn.init.constant_(m.bias, 0)
        elif isinstance(m, nn.LayerNorm):
            nn.init.constant_(m.bias, 0)
            nn.init.constant_(m.weight, 1.0)
        elif isinstance(m, nn.Conv2d):
            fan_out = m.kernel_size[0] * m.kernel_size[1] * m.out_channels
            fan_out //= m.groups
            m.weight.data.normal_(0, math.sqrt(2.0 / fan_out))
            if m.bias is not None:
                m.bias.data.zero_()
       
    def fuse_add(self, x, y):
        return x+y
    
    def fuse_pair_softmax(self, x, y):
        exp_x = torch.exp(x)
        exp_y = torch.exp(y)
        weight_x = exp_x / (exp_x+exp_y) 
        weight_y = exp_y / (exp_x+exp_y) 
        return weight_x*x + weight_y*y
        
    def forward(self, x, y):
        x, y = self.PE_x(x), self.PE_y(y)
        if self.mode == 'criss':
            b, c, h, w = x.shape
            self.position_emb_h = nn.Parameter(torch.rand(h, self.dim)).to(x.device)
            self.position_emb_w = nn.Parameter(torch.rand(w, self.dim)).to(x.device)
            trunc_normal_(self.position_emb_h, std=.02)
            trunc_normal_(self.position_emb_w, std=.02)
            position_emb = (self.position_emb_h.unsqueeze(dim=0).repeat(w.sz,1,1).permute(1,0,2)
                + self.position_emb_w.unsqueeze(dim=0).repeat(h,1,1)).permute(2, 0, 1) #=>dim, h//4, w//4
            x, y = x+position_emb, y+position_emb
        #x_, y_ = x, y
        output = []
        for i, block in enumerate(self.blocks):
            if i > 0:
                x, y = self.pm_xs[i-1](x+x_), self.pm_ys[i-1](y+y_)
            x_, y_ = x, y
            #print('blocks: '+str(i+1))
            for blk in block:
                x, y = blk.forward(x, y)
            x, y = self.norms[i](x), self.norms[i](y)
            #x, y = self.blocks[i](x, y)
            if 'abl' in self.kwargs and self.kwargs['abl'] is not None and \
                self.kwargs['abl'].split('_')[0]=='ablation' and self.kwargs['abl'].split('_')[1] == 'pairSoftmax':
                    output.append(self.fuse_pair_softmax(x, y))
            else:
                f = self.fuse_add(x, y)
                #print(f.shape)
                output.append(f)
        return output
